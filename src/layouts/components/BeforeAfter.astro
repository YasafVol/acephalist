---
import type { ImageMetadata } from "astro";
import { Image } from "astro:assets";

interface Props {
  beforeSrc: string;
  afterSrc: string;
  alt: string;
  width: number;
  height: number;
  class?: string;
}

const { beforeSrc, afterSrc, alt, width, height, class: className } = Astro.props;

// Prepend /public to image paths
const beforePath = `/public${beforeSrc}`;
const afterPath = `/public${afterSrc}`;

// Glob pattern to load images from the /public/images folder
const images = import.meta.glob("/public/images/**/*.{jpeg,jpg,png,gif}");

// Check if the source paths are valid
const isValidBeforePath = images[beforePath] ? true : false;
const isValidAfterPath = images[afterPath] ? true : false;

// Log warnings if images are not found
!isValidBeforePath &&
  console.error(
    `\x1b[31mBefore image not found - ${beforePath}.\x1b[0m Make sure the image is in the /public/images folder.`,
  );
!isValidAfterPath &&
  console.error(
    `\x1b[31mAfter image not found - ${afterPath}.\x1b[0m Make sure the image is in the /public/images folder.`,
  );
---

{isValidBeforePath && isValidAfterPath && (
  <div class={`before-after-container ${className || ''}`} style={`width: ${width}px; height: ${height}px;`}>
    <div class="before-after-wrapper" style={`width: ${width}px; height: ${height}px;`}>
      <!-- Before image (left side) -->
      <div class="before-after-image before-image">
        <Image
          src={images[beforePath]() as Promise<{ default: ImageMetadata }>}
          alt={`${alt} - Before`}
          width={width}
          height={height}
          format="webp"
          class="w-full h-full object-cover"
        />
      </div>
      
      <!-- After image (right side) -->
      <div class="before-after-image after-image" id="afterImage">
        <Image
          src={images[afterPath]() as Promise<{ default: ImageMetadata }>}
          alt={`${alt} - After`}
          width={width}
          height={height}
          format="webp"
          class="w-full h-full object-cover"
        />
      </div>
      
      <!-- Slider -->
      <div class="before-after-slider" id="slider">
        <div class="slider-line"></div>
      </div>
      
    </div>
  </div>
)}

<style>
  .before-after-container {
    position: relative;
    overflow: hidden;
    border-radius: 0.5rem;
    box-shadow: 0 4px 6px -1px rgb(0 0 0 / 0.1);
  }
  
  .before-after-wrapper {
    position: relative;
    margin: 0 auto;
  }
  
  .before-after-image {
    position: absolute;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
  }
  
  .before-image {
    z-index: 1;
  }
  
  .after-image {
    z-index: 2;
    clip-path: inset(0 50% 0 0);
    transition: clip-path 0.1s ease-out;
  }
  
  .before-after-slider {
    position: absolute;
    top: 0;
    left: 50%;
    width: 2px;
    height: 100%;
    background: rgba(128, 128, 128, 0.3);
    cursor: ew-resize;
    z-index: 3;
    transform: translateX(-50%);
    user-select: none;
  }
  
  .slider-line {
    width: 100%;
    height: 100%;
    background: linear-gradient(to bottom, 
      transparent 0%, 
      rgba(128, 128, 128, 0.2) 10%, 
      rgba(128, 128, 128, 0.2) 90%, 
      transparent 100%
    );
  }
</style>

<script>
  document.addEventListener('DOMContentLoaded', () => {
    const container = document.querySelector('.before-after-container');
    if (!container) return;
    
    const slider = document.getElementById('slider');
    const afterImage = document.getElementById('afterImage');
    const wrapper = container.querySelector('.before-after-wrapper');
    
    if (!slider || !afterImage || !wrapper) return;
    
    let isDragging = false;
    let containerWidth = (wrapper as HTMLElement).offsetWidth;
    
    function updateSliderPosition(percentage: number) {
      // Clamp percentage between 0 and 100
      percentage = Math.max(0, Math.min(100, percentage));
      
      // Update slider position
      slider.style.left = `${percentage}%`;
      
      // Update after image clip-path
      afterImage.style.clipPath = `inset(0 ${100 - percentage}% 0 0)`;
    }
    
    function handleMouseMove(e: MouseEvent) {
      if (!isDragging) return;
      
      const rect = (wrapper as HTMLElement).getBoundingClientRect();
      const x = e.clientX - rect.left;
      const percentage = (x / containerWidth) * 100;
      
      updateSliderPosition(percentage);
    }
    
    function handleTouchMove(e: TouchEvent) {
      if (!isDragging) return;
      
      const rect = (wrapper as HTMLElement).getBoundingClientRect();
      const x = e.touches[0].clientX - rect.left;
      const percentage = (x / containerWidth) * 100;
      
      updateSliderPosition(percentage);
    }
    
    function startDragging() {
      isDragging = true;
      document.body.style.cursor = 'ew-resize';
      document.body.style.userSelect = 'none';
    }
    
    function stopDragging() {
      isDragging = false;
      document.body.style.cursor = '';
      document.body.style.userSelect = '';
    }
    
    // Mouse events
    slider.addEventListener('mousedown', startDragging);
    document.addEventListener('mousemove', handleMouseMove);
    document.addEventListener('mouseup', stopDragging);
    
    // Touch events
    slider.addEventListener('touchstart', startDragging);
    document.addEventListener('touchmove', handleTouchMove);
    document.addEventListener('touchend', stopDragging);
    
    // Update container width on resize
    window.addEventListener('resize', () => {
      containerWidth = (wrapper as HTMLElement).offsetWidth;
    });
    
    // Initialize at 50%
    updateSliderPosition(50);
  });
</script>
